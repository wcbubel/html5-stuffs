// Generated by CoffeeScript 1.6.2
(function() {
  var Food, GAME_HEIGHT, GAME_WIDTH, Game, Graphics, KEYCODES, Segment, log;

  KEYCODES = {
    13: "return",
    37: "left",
    38: "up",
    39: "right",
    40: "down"
  };

  GAME_WIDTH = 512;

  GAME_HEIGHT = 512;

  log = function() {};

  Graphics = {
    init: function() {
      this.canvas = document.getElementById("gamecanvas");
      this.canvas.width = GAME_WIDTH;
      this.canvas.height = GAME_HEIGHT;
      this.ctx = this.canvas.getContext("2d");
      return this.rect();
    },
    isCanvasSupported: function() {
      var elem;

      elem = document.createElement('canvas');
      return !!(elem.getContext && elem.getContext('2d'));
    },
    rect: function(color, x, y, w, h) {
      if (color == null) {
        color = "#000000";
      }
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (w == null) {
        w = GAME_WIDTH;
      }
      if (h == null) {
        h = GAME_HEIGHT;
      }
      this.ctx.beginPath();
      this.ctx.rect(x, y, w, h);
      this.ctx.closePath();
      this.ctx.fillStyle = color;
      return this.ctx.fill();
    },
    drawSegment: function(x, y) {
      return this.rect("#33ff33", x * 16 + 1, y * 16 + 1, 14, 14);
    },
    drawHead: function(x, y) {
      return this.rect("#99ff33", x * 16 + 1, y * 16 + 1, 14, 14);
    },
    drawFood: function(x, y) {
      return this.rect("#33ffff", x * 16 + 2, y * 16 + 2, 12, 12);
    },
    writeText: function(text, x, y) {
      this.ctx.fillStyle = "#ffffff";
      this.ctx.beginPath();
      this.ctx.fillText(text, x, y);
      return this.ctx.closePath();
    }
  };

  Segment = (function() {
    function Segment(x, y) {
      this.x = x;
      this.y = y;
    }

    Segment.prototype.draw = function(head) {
      if (head) {
        return Graphics.drawHead(this.x, this.y);
      } else {
        return Graphics.drawSegment(this.x, this.y);
      }
    };

    Segment.prototype.overlaps = function(food) {
      return this.x === food.x && this.y === food.y;
    };

    Segment.prototype.outOfBounds = function() {
      return this.x < 0 || this.x >= 32 || this.y < 0 || this.y >= 32;
    };

    Segment.prototype.recycle = function(x, y) {
      this.x = x;
      this.y = y;
    };

    return Segment;

  })();

  Food = (function() {
    function Food(x, y) {
      this.x = x;
      this.y = y;
    }

    Food.prototype.draw = function() {
      return Graphics.drawFood(this.x, this.y);
    };

    return Food;

  })();

  Game = (function() {
    function Game() {
      var y, _i;

      this.snake = [];
      for (y = _i = 0; _i <= 2; y = ++_i) {
        this.snake.push(new Segment(16, 16 + y));
      }
      this.mode = "play";
      this.food = new Food(16, 16);
      this.dir = "up";
      this.next_dir = null;
      this.growth = 0;
      this.score = 0;
      this.recycle_bin = [];
      this.placeFood();
    }

    Game.prototype.changeDir = function(d) {
      return this.next_dir = d;
    };

    Game.prototype.verifiedChangeDir = function(old, next) {
      if (next == null) {
        next = old;
      }
      switch (old) {
        case "left":
          if (next !== "right") {
            return next;
          } else {
            return old;
          }
          break;
        case "up":
          if (next !== "down") {
            return next;
          } else {
            return old;
          }
          break;
        case "right":
          if (next !== "left") {
            return next;
          } else {
            return old;
          }
          break;
        case "down":
          if (next !== "up") {
            return next;
          } else {
            return old;
          }
          break;
        default:
          return old;
      }
    };

    Game.prototype.createSegment = function(x, y) {
      var segment;

      segment = null;
      if (this.recycle_bin.length > 0) {
        segment = this.recycle_bin.pop();
        segment.recycle(x, y);
        while (this.recycle_bin.length > 2) {
          this.recycle_bin.pop();
        }
      } else {
        log("Creating new segment");
        segment = new Segment(x, y);
      }
      return segment;
    };

    Game.prototype.placeFood = function() {
      var overlaps, ox, oy, segment, _i, _len, _ref;

      ox = Math.floor(Math.random() * 32);
      oy = Math.floor(Math.random() * 32);
      this.food.x = ox;
      this.food.y = oy;
      while (true) {
        overlaps = 0;
        _ref = this.snake;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          segment = _ref[_i];
          if (segment.overlaps(this.food)) {
            overlaps = true;
            break;
          }
        }
        if (!overlaps) {
          return;
        }
        this.food.x += 1;
        if (this.food.x >= 32) {
          this.food.x = 0;
          this.food.y = (this.food.y + 1) % 32;
        }
        if ((this.food.x === ox) && (this.food.y === oy)) {
          this.gameover(3);
          return;
        }
      }
    };

    Game.prototype.tick = function() {
      if (this.mode === "play") {
        this.update();
      }
      return this.draw();
    };

    Game.prototype.draw = function() {
      var first, segment, _i, _len, _ref;

      first = true;
      Graphics.rect();
      _ref = this.snake;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        segment.draw(first);
        first = false;
      }
      this.food.draw();
      if (this.mode === "gameover") {
        Graphics.writeText("GAMEOVER", 32, 32);
        Graphics.writeText("FINAL SCORE: " + this.score, 32, 48);
        return Graphics.writeText("PRESS ENTER TO RESTART", 32, 64);
      }
    };

    Game.prototype.update = function() {
      var head, old_head, segment, x, y, _i, _len, _ref;

      old_head = this.snake[0];
      x = old_head.x;
      y = old_head.y;
      this.dir = this.verifiedChangeDir(this.dir, this.next_dir);
      this.next_dir = null;
      switch (this.dir) {
        case "left":
          x -= 1;
          break;
        case "up":
          y -= 1;
          break;
        case "right":
          x += 1;
          break;
        case "down":
          y += 1;
      }
      head = this.createSegment(x, y);
      head = new Segment(x, y);
      _ref = this.snake;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        if (head.overlaps(segment)) {
          this.gameover(1);
          return;
        }
      }
      if (head.outOfBounds()) {
        this.gameover(2);
        return;
      }
      this.snake.unshift(head);
      if (head.overlaps(this.food)) {
        this.score++;
        this.placeFood();
        this.growth = 3;
      }
      if (this.growth <= 0) {
        return this.recycle_bin.push(this.snake.pop());
      } else {
        return this.growth -= 1;
      }
    };

    Game.prototype.gameover = function(id) {
      if (id == null) {
        id = 0;
      }
      log("gameover" + id);
      return this.mode = "gameover";
    };

    return Game;

  })();

  window.onload = function() {
    var game, listener, newGame, tickId;

    if (!Graphics.isCanvasSupported()) {
      return;
    }
    tickId = null;
    game = null;
    newGame = function() {
      game = new Game;
      if (tickId) {
        window.clearInterval(tickId);
      }
      return tickId = window.setInterval(game.tick.bind(game), 125);
    };
    listener = function(evt) {
      if (evt.keyCode in KEYCODES) {
        if (KEYCODES[evt.keyCode] === "return") {
          return newGame();
        } else {
          return game.changeDir(KEYCODES[evt.keyCode]);
        }
      }
    };
    Graphics.init();
    newGame();
    return window.addEventListener('keydown', listener, true);
  };

}).call(this);
